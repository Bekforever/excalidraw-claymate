{"version":3,"sources":["exportToGif.ts","exportToHtml.ts","AnimateConfig.tsx","importFromFile.ts","Claymate.tsx","creation.ts","persistence.ts","useScenes.ts","useLibrary.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["exportToGif","scenes","Promise","resolve","gif","GIF","forEach","scene","index","last","length","addFrame","imageData","delay","on","blob","fileSave","fileName","then","render","getNonDeletedElements","elements","filter","element","isDeleted","exportToHtml","options","a","html","darkMode","enabled","animate","exportToSvg","drawing","appState","exportWithDarkMode","svg","animateSvg","animateOptions","id","style","display","outerHTML","beginTimeList","getBeginTimeList","sort","b","JSON","stringify","animateButtons","Blob","type","previewHtml","divId","ele","document","getElementById","innerHTML","win","window","open","body","extractNumberFromId","key","match","RegExp","undefined","Number","applyNumberInId","ids","value","selectedElementIds","map","newId","includes","replace","AnimateConfig","animateEnabled","setAnimateEnabled","updateDrawing","setAnimateOptions","previewCurrentScene","selectedIds","Object","keys","some","animateOrderSet","Set","add","animateOrderDisabled","size","animateDurationSet","animateDurationDisabled","className","checked","onChange","x","disabled","onClick","opacity","values","next","e","Math","floor","target","isFinite","width","placeholder","pointerImg","prev","accept","file","files","reader","FileReader","onload","result","readAsDataURL","pointerWidth","importFromFile","name","endsWith","loadFromBlob","convertSvgToElements","startsWith","convertImageToElements","console","log","alert","text","svgToEx","convert","hasErrors","content","Error","createImageBitmap","bitmap","scale","max","height","canvas","createElement","ctx","getContext","drawImage","getImageData","groupId","nanoid","y","data","slice","r","g","version","versionNonce","fillStyle","strokeWidth","strokeStyle","roughness","angle","strokeColor","backgroundColor","seed","groupIds","strokeSharpness","boundElementIds","push","DARK_FILTER","Preview","memo","ref","useRef","useEffect","current","putImageData","Claymate","currentIndex","updateScenes","moveToScene","addScene","useState","showAnimateConfig","setShowAnimateConfig","theme","handleDrop","dataTransfer","drawingToAdd","exportGif","exportHtml","previewCurrentSceneInHtml","ondrop","testId","isEmpty","event","stopPropagation","findIndex","sc","remainingScenes","newCurrent","deletingCurrentScene","sourceIndex","item","deleteScene","tmp","moveLeft","moveRight","reverse","createScene","exportToCanvas","SCENE_STORAGE_KEY","loadStorage","firstScene","drawings","parse","localStorage","getItem","collaborators","Map","loadDrawingFromStorage","useScenes","initialised","setInitialised","drawingVersion","setDrawingVersion","setCurrentIndex","setScenes","setDrawing","initialScenes","s","setItem","saveStorage","requiredWidth","requiredHeight","onRestore","useCallback","updater","currentScene","optionalDrawing","isEqual","update","el","initialData","LIBRARY_STORAGE_KEY","useLibrary","initialLibraryItems","useMemo","storage","items","error","loadLibraries","libraryRef","onLibraryChange","saveLibraries","libraryItems","App","excalidrawRef","initialSceneData","updateScene","Boolean","location","hostname","ReactDOM","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.4c0f5460.chunk.js","sourcesContent":["import { fileSave } from \"browser-fs-access\";\n// @ts-ignore\nimport GIF from \"gif.js/dist/gif\";\n\nimport { Scene } from \"./types\";\n\nexport const exportToGif = (scenes: Scene[]) =>\n  new Promise((resolve) => {\n    const gif = new GIF();\n    scenes.forEach((scene, index) => {\n      const last = index + 1 === scenes.length;\n      gif.addFrame(scene.imageData, { delay: last ? 2000 : 500 });\n    });\n    gif.on(\"finished\", (blob: Blob) => {\n      fileSave(blob, {\n        fileName: \"excalidraw-claymate.gif\",\n      }).then(resolve);\n    });\n    gif.render();\n  });\n","import { fileSave } from \"browser-fs-access\";\nimport { exportToSvg } from \"@excalidraw/excalidraw\";\nimport type {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"@excalidraw/excalidraw/types/element/types\";\nimport { animateSvg, getBeginTimeList } from \"excalidraw-animate/dist/library\";\nimport { AnimateOptions } from \"./AnimateConfig\";\n\nimport { Scene } from \"./types\";\n\nconst DARK_FILTER = \"invert(93%) hue-rotate(180deg)\";\n\nconst getNonDeletedElements = (\n  elements: readonly ExcalidrawElement[]\n): NonDeletedExcalidrawElement[] =>\n  elements.filter(\n    (element): element is NonDeletedExcalidrawElement => !element.isDeleted\n  );\n\nconst getAnimateFunctions = (enabled: boolean) =>\n  enabled\n    ? `\n      function togglePausedAnimations() {\n        const svg = document.getElementById('scene' + index);\n        if (svg.animationsPaused()) {\n          for (const svg of document.getElementsByTagName('svg')) {\n            svg.unpauseAnimations();\n          }\n        } else {\n          for (const svg of document.getElementsByTagName('svg')) {\n            svg.pauseAnimations();\n          }\n        }\n      }\n      const beginTimeLists = [];\n      let animateTimer;\n      function stepForwardAnimations() {\n        const svg = document.getElementById('scene' + index);\n        const beginTimeList = beginTimeLists[index];\n        const currentTime = svg.getCurrentTime() * 1000;\n        let nextTime = beginTimeList.find((t) => t > currentTime + 50);\n        console.log(currentTime, beginTimeList, nextTime);\n        if (nextTime) {\n          nextTime -= 1;\n        } else {\n          nextTime = currentTime + 500;\n        }\n        clearTimeout(animateTimer);\n        svg.unpauseAnimations();\n        animateTimer = setTimeout(() => {\n          svg.pauseAnimations();\n          svg.setCurrentTime(nextTime / 1000);\n        }, nextTime - currentTime);\n      }\n      function resetAnimations() {\n        const svg = document.getElementById('scene' + index);\n        svg.setCurrentTime(0);\n      }\n`\n    : `\n      function togglePausedAnimations() {}\n      function stepForwardAnimations() {}\n      function resetAnimations() {}\n`;\n\nconst recordingFunction = `\n  function startRecording() {\n    import('https://unpkg.com/browser-fs-access').then(({ fileSave }) => {\n      navigator.mediaDevices.getDisplayMedia({\n        video: { displaySurface: 'browser' },\n      }).then(function(stream) {\n        navigator.mediaDevices.getUserMedia({\n          audio: true,\n        }).catch(() => null).then(function(audioStream) {\n          if (audioStream) {\n            const audioTrack = audioStream.getAudioTracks()[0];\n            stream.getVideoTracks()[0].onended = () => {\n              audioTrack.stop();\n            };\n            stream.addTrack(audioTrack);\n          }\n          const recorder = new MediaRecorder(stream);\n          recorder.ondataavailable = (e) => {\n            const blob = new Blob([e.data], { type: \"video/webm\" });\n            const opts = { fileName: \"video.webm\", extensions: [\".webm\"] };\n            fileSave(blob, opts).catch(() => {\n              document.getElementById('startrecordingbutton').onclick = () => {\n                fileSave(blob, opts);\n              };\n              window.alert('Click the recording button again to save file');\n            });\n          };\n          recorder.start();\n        });\n      });\n    });\n  }\n`;\n\ntype Options = {\n  darkMode: boolean;\n  animate?: boolean;\n  animateOptions?: AnimateOptions;\n};\n\nexport const exportToHtml = async (scenes: Scene[], options: Options) => {\n  let html = `<!DOCTYPE html>\n    <html lang=\"en\">\n      <style>\n        svg { width: 100%; height: 100%; }\n        body { margin: 0px; font-size: 24px; ${\n          options.darkMode ? `filter: ${DARK_FILTER}; ` : \"\"\n        }}\n        button { background: transparent; border: none; cursor: pointer; padding: 3px; margin: 0px 10px; font-size: inherit;}\n        #container { display: flex; flex-direction: column; height: 100%; background: white; }\n        #navigation { display: flex; justify-content: center; align-items: center; padding: 5px; border-top: 1px solid lightgray; background: white; }\n        #leftbuttons { position: absolute; left: 10px; display: flex; }\n        #rightbuttons { position: absolute; right: 10px; display: flex; }\n        #slides { height: calc(100vh - 50px); }\n      </style>\n      <script>\n        let index = 0;\n        let totalScenes = ${scenes.length}\n        function updateTitle() {\n          document.getElementById('title').innerText = '' + (index + 1) + ' of ' + totalScenes;\n        }\n        function moveLeft() {\n          if (index > 0) {\n            document.getElementById('scene' + index).style.display = 'none';\n            index -= 1;\n            document.getElementById('scene' + index).style.display = 'block';\n            updateTitle();\n            document.getElementById('scene' + index).setCurrentTime(0);\n          }\n        }\n        function moveRight() {\n          if (index < totalScenes - 1) {\n            document.getElementById('scene' + index).style.display = 'none';\n            index += 1;\n            document.getElementById('scene' + index).style.display = 'block';\n            updateTitle();\n            document.getElementById('scene' + index).setCurrentTime(0);\n          }\n        }\n        function closeNavigation() {\n          document.getElementById('navigation').style.display = 'none';\n          document.getElementById('slides').style.height = '100vh'\n        }\n        function toggleMaximise() {\n          if (document.fullscreenElement === document.body) {\n            document.exitFullscreen();\n          } else {\n            document.body.requestFullscreen();\n          }\n        }\n        ${getAnimateFunctions(!!options.animate)}\n        ${recordingFunction}\n        document.addEventListener('DOMContentLoaded', () => {\n          document.getElementById('scene' + index).style.display = 'block';\n          document.getElementById('scene' + index).setCurrentTime(0);\n        });\n        document.addEventListener('keydown', (event) => {\n          if (event.key === 'ArrowRight') {\n            moveRight();\n          }\n          if (event.key === 'ArrowLeft') {\n            moveLeft();\n          }\n          if (event.key.toLowerCase() === 'f') {\n            toggleMaximise();\n          }\n          if (event.key.toLowerCase() === 'p') {\n            togglePausedAnimations();\n          }\n          if (event.key.toLowerCase() === 's') {\n            stepForwardAnimations();\n          }\n          if (event.key.toLowerCase() === 'r') {\n            resetAnimations();\n          }\n        });\n      </script>\n      <body>\n      <div id=\"container\">\n      <div id=\"slides\">\n  `;\n  for (let index = 0; index < scenes.length; ++index) {\n    const scene = scenes[index];\n    const svg: SVGSVGElement = await exportToSvg({\n      ...scene.drawing,\n      appState: {\n        ...scene.drawing.appState,\n        exportWithDarkMode: false,\n      },\n    });\n    if (options.animate) {\n      animateSvg(\n        svg,\n        getNonDeletedElements(scene.drawing.elements),\n        options.animateOptions\n      );\n    }\n    svg.id = `scene${index}`;\n    svg.style.display = \"none\";\n    html += svg.outerHTML;\n    if (options.animate) {\n      const beginTimeList = getBeginTimeList(svg);\n      beginTimeList.sort((a, b) => a - b);\n      html += `\n        <script>\n          beginTimeLists.push(${JSON.stringify(beginTimeList)});\n        </script>\n      `;\n    }\n  }\n  const animateButtons = options.animate\n    ? `\n    <div id=\"leftbuttons\">\n     <button type=\"button\" onclick=\"togglePausedAnimations()\" title=\"Play or pause animations\">P</button>\n     <button type=\"button\" onclick=\"stepForwardAnimations()\" title=\"Step forward animations\">S</button>\n     <button type=\"button\" onclick=\"resetAnimations()\" title=\"Reset animations\">R</button>\n    </div>\n`\n    : \"\";\n  html += `\n    </div>\n    <div id=\"navigation\">\n      ${animateButtons}\n      <button class=\"navbutton\" type=\"button\" onclick=\"moveLeft()\" title=\"Previous slide\">&#9664;</button>\n      <div id=\"title\">1 of ${scenes.length}</div>\n      <button class=\"navbutton\" type=\"button\" onclick=\"moveRight()\" title=\"Next slide\">&#9654;</button>\n      <div id=\"rightbuttons\">\n        <button type=\"button\" onclick=\"startRecording()\" title=\"Start recording\" id=\"startrecordingbutton\">&#x1F3A5;</button>\n        <button type=\"button\" onclick=\"toggleMaximise()\" title=\"Toggle full-screen\">&#x26F6;</button>\n        <button type=\"button\" onclick=\"closeNavigation()\" title=\"Close this panel\">&#x2716;</button>\n      </div>\n    </div>\n  </div></body></html>\n`;\n  await fileSave(new Blob([html], { type: \"text/html\" }), {\n    fileName: \"excalidraw-claymate.html\",\n  });\n};\n\nexport const previewHtml = async (\n  scene: Scene,\n  options: Options,\n  divId?: string\n) => {\n  const svg: SVGSVGElement = await exportToSvg(scene.drawing);\n  if (options.animate) {\n    animateSvg(\n      svg,\n      getNonDeletedElements(scene.drawing.elements),\n      options.animateOptions\n    );\n  }\n  const html = svg.outerHTML;\n  if (divId) {\n    const ele = document.getElementById(divId);\n    if (ele) {\n      ele.innerHTML = html;\n    }\n  } else {\n    const win = window.open(\"\", \"_blank\");\n    if (win) {\n      win.document.body.innerHTML = html;\n    }\n  }\n};\n","import { ChangeEvent, Dispatch, SetStateAction } from \"react\";\n\nimport \"./AnimateConfig.css\";\nimport { Drawing, Scene } from \"./types\";\n\nconst extractNumberFromId = (id: string, key: string) => {\n  const match = id.match(new RegExp(`${key}:(-?\\\\d+)`));\n  return match === null ? undefined : Number(match[1]) || 0;\n};\n\nconst applyNumberInId = (\n  drawing: Drawing,\n  ids: string[],\n  key: string,\n  value: number\n): Drawing => {\n  const selectedElementIds = { ...drawing.appState.selectedElementIds };\n  const elements = drawing.elements.map((element) => {\n    const { id } = element;\n    if (!ids.includes(id)) {\n      return element;\n    }\n    let newId: string;\n    const match = id.match(new RegExp(`${key}:(-?\\\\d+)`));\n    if (match) {\n      newId = id.replace(new RegExp(`${key}:(-?\\\\d+)`), `${key}:${value}`);\n    } else {\n      newId = id + `-${key}:${value}`;\n    }\n    if (id === newId) {\n      return element;\n    }\n    selectedElementIds[newId] = selectedElementIds[id];\n    delete selectedElementIds[id];\n    return { ...element, id: newId };\n  });\n  return {\n    elements,\n    appState: {\n      ...drawing.appState,\n      selectedElementIds,\n    },\n  };\n};\n\nexport type AnimateOptions = {\n  pointerImg?: string;\n  pointerWidth?: string;\n};\n\ntype Props = {\n  animateEnabled: boolean;\n  setAnimateEnabled: Dispatch<SetStateAction<boolean>>;\n  scene: Scene | undefined;\n  updateDrawing: (drawing: Drawing) => void;\n  animateOptions: AnimateOptions;\n  setAnimateOptions: Dispatch<SetStateAction<AnimateOptions>>;\n  previewCurrentScene: () => void;\n};\n\nconst AnimateConfig = ({\n  animateEnabled,\n  setAnimateEnabled,\n  scene,\n  updateDrawing,\n  animateOptions,\n  setAnimateOptions,\n  previewCurrentScene,\n}: Props) => {\n  const elements = scene?.drawing.elements ?? [];\n  const selectedIds = scene\n    ? Object.keys(scene.drawing.appState.selectedElementIds ?? {}).filter(\n        (id) =>\n          scene.drawing.appState.selectedElementIds[id] &&\n          elements.some((element) => element.id === id)\n      )\n    : [];\n\n  const animateOrderSet = new Set<number | undefined>();\n  selectedIds.forEach((id) => {\n    animateOrderSet.add(extractNumberFromId(id, \"animateOrder\"));\n  });\n  const onChangeAnimateOrder = (e: ChangeEvent<HTMLInputElement>) => {\n    const value = Math.floor(Number(e.target.value));\n    if (scene && Number.isFinite(value)) {\n      updateDrawing(\n        applyNumberInId(scene.drawing, selectedIds, \"animateOrder\", value)\n      );\n    }\n  };\n  const animateOrderDisabled = !animateEnabled || !animateOrderSet.size;\n\n  const animateDurationSet = new Set<number | undefined>();\n  selectedIds.forEach((id) => {\n    animateDurationSet.add(extractNumberFromId(id, \"animateDuration\"));\n  });\n  const onChangeAnimateDuration = (e: ChangeEvent<HTMLInputElement>) => {\n    const value = Math.floor(Number(e.target.value));\n    if (scene && Number.isFinite(value)) {\n      updateDrawing(\n        applyNumberInId(scene.drawing, selectedIds, \"animateDuration\", value)\n      );\n    }\n  };\n  const animateDurationDisabled = !animateEnabled || !animateDurationSet.size;\n\n  const onChangeAnimatePointerText = (e: ChangeEvent<HTMLInputElement>) => {\n    setAnimateOptions((prev) => ({\n      ...prev,\n      pointerImg: e.target.value,\n    }));\n  };\n\n  const onChangeAnimatePointerFile = (e: ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files && e.target.files[0];\n    if (!file) {\n      return;\n    }\n    const reader = new FileReader();\n    reader.onload = () => {\n      if (typeof reader.result === \"string\") {\n        const pointerImg = reader.result;\n        setAnimateOptions((prev) => ({ ...prev, pointerImg }));\n      }\n    };\n    reader.readAsDataURL(file);\n  };\n\n  const onChangeAnimatePointerWidth = (e: ChangeEvent<HTMLInputElement>) => {\n    setAnimateOptions((prev) => ({\n      ...prev,\n      pointerWidth: e.target.value,\n    }));\n  };\n\n  return (\n    <div className=\"AnimateConfig\">\n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={animateEnabled}\n            onChange={() => setAnimateEnabled((x) => !x)}\n          />\n          Enable animate\n        </label>{\" \"}\n        <button disabled={!animateEnabled} onClick={previewCurrentScene}>\n          Preview\n        </button>\n      </div>\n      <div style={{ opacity: animateOrderDisabled ? 0.3 : 1.0 }}>\n        Animate order:{\" \"}\n        {animateOrderSet.size > 1 ? (\n          <>(mixed)</>\n        ) : (\n          <input\n            disabled={animateOrderDisabled}\n            value={\n              (animateOrderSet.size === 1 &&\n                animateOrderSet.values().next().value) ||\n              0\n            }\n            onChange={onChangeAnimateOrder}\n            type=\"number\"\n            style={{ width: 40 }}\n          />\n        )}\n      </div>\n      <div style={{ opacity: animateDurationDisabled ? 0.3 : 1.0 }}>\n        Animate duration (ms):{\" \"}\n        {animateDurationSet.size > 1 ? (\n          <>(mixed)</>\n        ) : (\n          <input\n            disabled={animateDurationDisabled}\n            value={\n              (animateDurationSet.size === 1 &&\n                animateDurationSet.values().next().value) ||\n              \"\"\n            }\n            onChange={onChangeAnimateDuration}\n            placeholder=\"Default\"\n            style={{ width: 50 }}\n          />\n        )}\n      </div>\n      <div style={{ opacity: !animateEnabled ? 0.3 : 1.0 }}>\n        Animate pointer:{\" \"}\n        <input\n          disabled={!animateEnabled}\n          value={animateOptions.pointerImg || \"\"}\n          onChange={onChangeAnimatePointerText}\n          placeholder=\"URL...\"\n          style={{ width: 50 }}\n        />{\" \"}\n        <label\n          className={`AnimateConfig-button-like ${\n            animateEnabled\n              ? \"AnimateConfig-button-like-enabled\"\n              : \"AnimateConfig-button-like-disabled\"\n          }`}\n        >\n          <input\n            disabled={!animateEnabled}\n            type=\"file\"\n            accept=\"image/*\"\n            onChange={onChangeAnimatePointerFile}\n            style={{ width: 0 }}\n          />\n          File\n        </label>\n      </div>\n      <div style={{ opacity: !animateEnabled ? 0.3 : 1.0 }}>\n        (Pointer width:{\" \"}\n        <input\n          disabled={!animateEnabled}\n          value={animateOptions.pointerWidth || \"\"}\n          onChange={onChangeAnimatePointerWidth}\n          placeholder=\"Num...\"\n          style={{ width: 50 }}\n        />\n        )\n      </div>\n    </div>\n  );\n};\n\nexport default AnimateConfig;\n","import { ExcalidrawElement } from \"@excalidraw/excalidraw/types/element/types\";\nimport { AppState } from \"@excalidraw/excalidraw/types/types\";\nimport { loadFromBlob } from \"@excalidraw/excalidraw\";\nimport svgToEx from \"svg-to-excalidraw\";\nimport { nanoid } from \"nanoid\";\n\nimport { Drawing } from \"./types\";\n\nexport const importFromFile = async (\n  file: File,\n  appState: AppState\n): Promise<Drawing | null> => {\n  if (file.name.endsWith(\".excalidraw\")) {\n    const result = await loadFromBlob(file, appState, null);\n    return {\n      ...result,\n      appState: { ...appState, ...result.appState },\n    };\n  }\n  if (file.type === \"image/svg+xml\") {\n    const elements = await convertSvgToElements(file);\n    return { elements, appState };\n  }\n  if (file.type.startsWith(\"image/\")) {\n    const elements = await convertImageToElements(file);\n    return { elements, appState };\n  }\n  console.log(\"Unsupported file dropped\", file);\n  window.alert(\"Unsupported file dropped\");\n  return null;\n};\n\nexport const convertSvgToElements = async (\n  file: File\n): Promise<Drawing[\"elements\"]> => {\n  const text = await file.text();\n  const { hasErrors, content } = svgToEx.convert(text);\n  if (hasErrors) {\n    throw Error(\"Error in convertSvgToElements\");\n  }\n  return content.elements;\n};\n\nexport const convertImageToElements = async (\n  file: File\n): Promise<Drawing[\"elements\"]> => {\n  const bitmap = await createImageBitmap(file);\n  const scale = 64 / Math.max(bitmap.width, bitmap.height);\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = bitmap.width * scale;\n  canvas.height = bitmap.height * scale;\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) {\n    throw Error(\"Error in convertSvgToElements\");\n  }\n  ctx.drawImage(\n    bitmap,\n    0,\n    0,\n    bitmap.width,\n    bitmap.height,\n    0,\n    0,\n    canvas.width,\n    canvas.height\n  );\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const elements: ExcalidrawElement[] = [];\n  const groupId = nanoid();\n  for (let y = 0; y < canvas.height; ++y) {\n    for (let x = 0; x < canvas.width; ++x) {\n      const [r, g, b, a] = imageData.data.slice((y * canvas.width + x) * 4);\n      const element: ExcalidrawElement = {\n        type: \"rectangle\",\n        version: 1,\n        versionNonce: 0,\n        isDeleted: false,\n        id: nanoid(),\n        fillStyle: \"solid\",\n        strokeWidth: 1,\n        strokeStyle: \"solid\",\n        roughness: 0,\n        opacity: 100,\n        angle: 0,\n        x: 300 + x * 5,\n        y: 100 + y * 5,\n        strokeColor: \"transparent\",\n        backgroundColor: `rgba(${r},${g},${b},${a})`,\n        width: 5,\n        height: 5,\n        seed: 0,\n        groupIds: [groupId],\n        strokeSharpness: \"sharp\",\n        boundElementIds: [],\n      };\n      elements.push(element);\n    }\n  }\n  return elements;\n};\n","import { memo, useState, useEffect, useRef } from \"react\";\nimport { isEmpty } from \"lodash\";\n\nimport \"./Claymate.css\";\nimport { Drawing, Scene } from \"./types\";\nimport { exportToGif } from \"./exportToGif\";\nimport { exportToHtml, previewHtml } from \"./exportToHtml\";\nimport AnimateConfig, { AnimateOptions } from \"./AnimateConfig\";\nimport { importFromFile } from \"./importFromFile\";\n\nconst DARK_FILTER = \"invert(93%) hue-rotate(180deg)\";\n\nconst Preview = memo<{ scene: Scene; darkMode: boolean }>(\n  ({ scene, darkMode }) => {\n    const ref = useRef<HTMLCanvasElement>(null);\n    useEffect(() => {\n      if (!ref.current) return;\n      const ctx = ref.current.getContext(\"2d\");\n      if (!ctx) return;\n      ctx.putImageData(scene.imageData, 0, 0);\n    }, [scene]);\n    return (\n      <canvas\n        ref={ref}\n        width={scene.width}\n        height={scene.height}\n        style={{\n          filter: darkMode ? DARK_FILTER : undefined,\n        }}\n      />\n    );\n  }\n);\n\ntype Props = {\n  currentIndex: number | undefined;\n  scenes: Scene[];\n  updateScenes: (\n    updater: (prev: Scene[]) => Scene[],\n    newCurrent?: { index: number; drawing: Drawing }\n  ) => void;\n  moveToScene: (index: number) => void;\n  addScene: (optionalDrawing?: Drawing) => void;\n  updateDrawing: (drawing: Drawing) => void;\n};\n\nconst Claymate = ({\n  scenes,\n  currentIndex,\n  updateScenes,\n  moveToScene,\n  addScene,\n  updateDrawing,\n}: Props) => {\n  const [showAnimateConfig, setShowAnimateConfig] = useState(false);\n  const [animateEnabled, setAnimateEnabled] = useState(false);\n  const [animateOptions, setAnimateOptions] = useState<AnimateOptions>({});\n\n  const darkMode = scenes[currentIndex || 0]?.drawing.appState.theme === \"dark\";\n\n  const handleDrop = useRef<(e: DragEvent) => void>();\n  useEffect(() => {\n    handleDrop.current = async (e: DragEvent) => {\n      const file = e.dataTransfer?.files[0];\n      const appState =\n        currentIndex !== undefined && scenes[currentIndex].drawing.appState;\n      if (file && appState) {\n        const drawingToAdd = await importFromFile(file, appState);\n        if (drawingToAdd) {\n          addScene(drawingToAdd);\n        }\n      }\n    };\n  });\n\n  const exportGif = async () => {\n    await exportToGif(scenes);\n  };\n\n  const exportHtml = async () => {\n    await exportToHtml(scenes, {\n      darkMode,\n      animate: animateEnabled,\n      animateOptions,\n    });\n  };\n\n  const previewCurrentSceneInHtml = async () => {\n    if (currentIndex !== undefined) {\n      let divId = \"\";\n      const ele = document.getElementById(\"previewOuter\");\n      if (ele) {\n        divId = \"previewInner\";\n      }\n      await previewHtml(\n        scenes[currentIndex],\n        {\n          darkMode,\n          animate: animateEnabled,\n          animateOptions,\n        },\n        divId\n      );\n      if (ele) {\n        ele.style.display = \"block\";\n      }\n    }\n  };\n\n  const deleteScene = (id: string) => {\n    const index = scenes.findIndex((sc) => sc.id === id);\n    if (index >= 0) {\n      const remainingScenes = scenes.length - 1;\n      if (remainingScenes > 0) {\n        let newCurrent;\n        if (currentIndex !== undefined) {\n          const deletingCurrentScene = index === currentIndex;\n          if (currentIndex > index || deletingCurrentScene) {\n            let sourceIndex = currentIndex;\n            if (deletingCurrentScene) {\n              if (currentIndex === remainingScenes) {\n                sourceIndex = currentIndex - 1;\n              } else if (currentIndex === 0) {\n                sourceIndex = 1;\n              }\n            }\n            newCurrent = {\n              index: currentIndex > 0 ? currentIndex - 1 : currentIndex,\n              drawing: scenes[sourceIndex].drawing,\n            };\n          }\n        }\n        updateScenes(\n          (prev: Scene[]) => prev.filter((item) => item.id !== id),\n          newCurrent\n        );\n      }\n    }\n  };\n\n  const moveLeft = (id: string) => {\n    const index = scenes.findIndex((item) => item.id === id);\n    updateScenes(\n      (prev) => {\n        const tmp = [...prev];\n        tmp[index - 1] = prev[index];\n        tmp[index] = prev[index - 1];\n        return tmp;\n      },\n      { index: index - 1, drawing: scenes[index].drawing }\n    );\n  };\n\n  const moveRight = (id: string) => {\n    const index = scenes.findIndex((item) => item.id === id);\n    updateScenes(\n      (prev) => {\n        const tmp = [...prev];\n        tmp[index + 1] = prev[index];\n        tmp[index] = prev[index + 1];\n        return tmp;\n      },\n      { index: index + 1, drawing: scenes[index].drawing }\n    );\n  };\n\n  const reverseOrder = () => {\n    updateScenes(\n      (prev) => [...prev].reverse(),\n      currentIndex !== undefined\n        ? {\n            index: scenes.length - 1 - currentIndex,\n            drawing: scenes[currentIndex].drawing,\n          }\n        : undefined\n    );\n  };\n\n  useEffect(() => {\n    if (scenes.length === 0) {\n      addScene();\n    }\n  }, [scenes, addScene]);\n\n  return (\n    <div\n      className=\"Claymate\"\n      style={{\n        filter: darkMode ? DARK_FILTER : undefined,\n      }}\n      ref={(ele) => {\n        if (ele) {\n          ele.ondrop = (e) => handleDrop.current?.(e);\n        }\n      }}\n    >\n      <div className=\"Claymate-scenes\">\n        {scenes.map((scene, index) => {\n          let testId = \"MissingId\";\n          if (!isEmpty(scenes[index].drawing.elements)) {\n            testId = scenes[index].drawing.elements[0].id;\n          }\n          return (\n            <div\n              key={scene.id}\n              className={`Claymate-scene ${\n                index === currentIndex ? \"Claymate-current-scene\" : \"\"\n              }`}\n              onClick={() => moveToScene(index)}\n              data-testid={testId}\n            >\n              <Preview scene={scene} darkMode={darkMode} />\n              <button\n                type=\"button\"\n                className=\"Claymate-delete\"\n                aria-label=\"Delete\"\n                disabled={scenes.length <= 1}\n                onClick={(event) => {\n                  event.stopPropagation();\n                  deleteScene(scene.id);\n                }}\n              >\n                &#x2716;\n              </button>\n              <button\n                type=\"button\"\n                className=\"Claymate-left\"\n                aria-label=\"Move Left\"\n                disabled={index === 0}\n                onClick={(event) => {\n                  event.stopPropagation();\n                  moveLeft(scene.id);\n                }}\n              >\n                &#x2b05;\n              </button>\n              <button\n                type=\"button\"\n                className=\"Claymate-right\"\n                aria-label=\"Move Right\"\n                disabled={index === scenes.length - 1}\n                onClick={(event) => {\n                  event.stopPropagation();\n                  moveRight(scene.id);\n                }}\n              >\n                &#x27a1;\n              </button>\n            </div>\n          );\n        })}\n      </div>\n      <div className=\"Claymate-configs\">\n        {showAnimateConfig && (\n          <AnimateConfig\n            animateEnabled={animateEnabled}\n            setAnimateEnabled={setAnimateEnabled}\n            scene={\n              currentIndex === undefined ? undefined : scenes[currentIndex]\n            }\n            updateDrawing={updateDrawing}\n            animateOptions={animateOptions}\n            setAnimateOptions={setAnimateOptions}\n            previewCurrentScene={previewCurrentSceneInHtml}\n          />\n        )}\n      </div>\n      <div className=\"Claymate-buttons\">\n        <button type=\"button\" onClick={() => addScene()}>\n          Add scene\n        </button>\n        <button\n          type=\"button\"\n          onClick={exportGif}\n          disabled={scenes.length === 0}\n        >\n          Export GIF\n        </button>\n        <div>\n          <button type=\"button\" onClick={() => setShowAnimateConfig((x) => !x)}>\n            {showAnimateConfig ? <>&#9656;</> : <>&#9666;</>}\n          </button>\n          <button\n            type=\"button\"\n            onClick={() => exportHtml()}\n            disabled={scenes.length === 0}\n          >\n            Export HTML\n          </button>\n        </div>\n        <button\n          type=\"button\"\n          onClick={reverseOrder}\n          disabled={scenes.length <= 1}\n        >\n          Reverse order\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default Claymate;\n","import { nanoid } from \"nanoid\";\nimport { exportToCanvas } from \"@excalidraw/excalidraw\";\nimport { Drawing, Scene } from \"./types\";\n\nexport const createScene = (\n  drawing: Drawing,\n  size?: { width: number; height: number }\n): Scene | undefined => {\n  const canvas = exportToCanvas(drawing);\n  const width = size ? size.width : canvas.width;\n  const height = size ? size.height : canvas.height;\n  if (!width || !height) {\n    return;\n  }\n  const ctx = canvas.getContext(\"2d\");\n  if (ctx) {\n    return {\n      id: nanoid(),\n      width,\n      height,\n      imageData: ctx.getImageData(0, 0, width, height),\n      drawing,\n    };\n  }\n};\n","import { createScene } from \"./creation\";\nimport { Drawing, Scene } from \"./types\";\n\nconst ELEMENTS_STORAGE_KEY = \"excalidraw-elements\";\nconst SCENE_STORAGE_KEY = \"claymate-scenes\";\n\nconst loadDrawingFromStorage = (): Drawing | null => {\n  try {\n    const data = JSON.parse(localStorage.getItem(ELEMENTS_STORAGE_KEY) || \"\");\n    data.appState.collaborators = new Map();\n    return data;\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const loadStorage = (): Scene[] | null => {\n  try {\n    const drawings = JSON.parse(\n      localStorage.getItem(SCENE_STORAGE_KEY) || \"\"\n    ) as Drawing[];\n    if (drawings && drawings.length > 0) {\n      let firstScene: Scene | undefined;\n      return drawings.map((drawing) => {\n        drawing.appState.collaborators = new Map();\n        const scene = createScene(\n          drawing,\n          firstScene\n            ? { width: firstScene.width, height: firstScene.height }\n            : undefined\n        );\n        if (firstScene === undefined) {\n          firstScene = scene;\n        }\n        return scene;\n      }) as Scene[];\n    }\n  } catch {\n    try {\n      const drawing = loadDrawingFromStorage();\n      if (drawing) {\n        const scene = createScene(drawing);\n        if (scene) {\n          return [scene];\n        }\n      }\n    } catch {}\n  }\n  return null;\n};\n\nexport const saveStorage = (scenes: Scene[]) => {\n  const result = JSON.stringify(scenes.map((s) => s.drawing));\n  localStorage.setItem(SCENE_STORAGE_KEY, result);\n};\n","import { useCallback, useEffect, useState } from \"react\";\nimport { AppState } from \"@excalidraw/excalidraw/types/types\";\nimport { ExcalidrawElement } from \"@excalidraw/excalidraw/types/element/types\";\nimport isEqual from \"lodash/isEqual\";\nimport { createScene } from \"./creation\";\nimport { Drawing, Scene } from \"./types\";\nimport { loadStorage, saveStorage } from \"./persistence\";\n\nexport const useScenes = () => {\n  const [initialised, setInitialised] = useState(false);\n  const [drawingVersion, setDrawingVersion] = useState(0);\n  const [currentIndex, setCurrentIndex] = useState<number | undefined>(0);\n  const [scenes, setScenes] = useState<Scene[]>([]);\n  const [drawing, setDrawing] = useState<Drawing | undefined>();\n\n  useEffect(() => {\n    if (!initialised) {\n      const initialScenes = loadStorage();\n      if (initialScenes && initialScenes.length > 0) {\n        setScenes(initialScenes);\n        setCurrentIndex(0);\n        setDrawing(initialScenes[0].drawing);\n      }\n    }\n  }, [initialised, setInitialised]);\n\n  useEffect(() => {\n    saveStorage(scenes);\n  }, [scenes]);\n\n  const onRestore = useCallback((drawing: Drawing) => {\n    setDrawingVersion((version) => version + 1);\n    setDrawing(drawing);\n  }, []);\n\n  const moveToScene = useCallback(\n    (index: number) => {\n      onRestore(scenes[index].drawing);\n      setCurrentIndex(index);\n    },\n    [onRestore, setCurrentIndex, scenes]\n  );\n\n  const onChange = (\n    elements: readonly ExcalidrawElement[],\n    appState: AppState\n  ) => {\n    if (\n      drawing == null ||\n      !isEqual(elements, drawing.elements) ||\n      !isEqual(appState, drawing.appState)\n    ) {\n      const update = {\n        elements: elements.map((el) => {\n          return { ...(el as any) };\n        }),\n        appState: { ...(appState as any) },\n      };\n      setDrawing(update);\n    }\n  };\n\n  const updateScenes = useCallback(\n    (\n      updater: (prev: Scene[]) => Scene[],\n      newCurrent?: { index: number; drawing: Drawing }\n    ) => {\n      setScenes(updater);\n      if (newCurrent) {\n        setCurrentIndex(newCurrent.index);\n        onRestore(newCurrent.drawing);\n      }\n    },\n    [setCurrentIndex, onRestore, setScenes]\n  );\n\n  const currentScene =\n    currentIndex !== undefined && currentIndex < scenes.length\n      ? { ...scenes[currentIndex], drawing }\n      : undefined;\n\n  let requiredWidth: number | undefined;\n  let requiredHeight: number | undefined;\n  if (currentScene != null && scenes.length !== 1) {\n    requiredWidth = currentScene.width;\n    requiredHeight = currentScene.height;\n  }\n\n  useEffect(() => {\n    if (currentIndex != null && drawing) {\n      const scene = createScene(\n        drawing,\n        requiredWidth === undefined || requiredHeight === undefined\n          ? undefined\n          : {\n              width: requiredWidth,\n              height: requiredHeight,\n            }\n      );\n      if (scene) {\n        updateScenes((prev) => {\n          const result = [...prev];\n          result[currentIndex] = scene;\n          return result;\n        }, undefined);\n      }\n    }\n  }, [\n    drawing,\n    currentIndex,\n    scenes.length,\n    updateScenes,\n    requiredWidth,\n    requiredHeight,\n  ]);\n\n  const addScene = useCallback(\n    (optionalDrawing?: Drawing) => {\n      const drawingToAdd = optionalDrawing || drawing;\n      if (drawingToAdd) {\n        const scene = createScene(\n          drawingToAdd,\n          scenes[0] && {\n            width: scenes[0].width,\n            height: scenes[0].height,\n          }\n        );\n        if (scene) {\n          updateScenes((prev) => [...prev, scene], {\n            index: scenes.length,\n            drawing: drawingToAdd,\n          });\n        }\n      }\n    },\n    [updateScenes, scenes, drawing]\n  );\n\n  return {\n    initialised,\n    moveToScene,\n    addScene,\n    onChange,\n    drawingVersion,\n    currentIndex,\n    scenes,\n    updateScenes,\n    initialData: drawing,\n  };\n};\n","import { LibraryItems } from \"@excalidraw/excalidraw/types/types\";\nimport { useCallback, useMemo, useRef } from \"react\";\n\nconst LIBRARY_STORAGE_KEY = \"claymate-libraries\";\n\nexport const loadLibraries = (): LibraryItems | undefined => {\n  try {\n    const storage = localStorage.getItem(LIBRARY_STORAGE_KEY);\n    const items = storage ? JSON.parse(storage) : undefined;\n    if (items) {\n      return items as LibraryItems;\n    }\n  } catch (e) {\n    console.error(\"Unable to load libraries\", e);\n  }\n  return undefined;\n};\n\nexport const saveLibraries = (items: LibraryItems) => {\n  const result = JSON.stringify(items);\n  localStorage.setItem(LIBRARY_STORAGE_KEY, result);\n};\n\nexport const useLibrary = () => {\n  const initialLibraryItems = useMemo(() => loadLibraries(), []);\n  const libraryRef = useRef<LibraryItems | undefined>(initialLibraryItems);\n  const onLibraryChange = useCallback((items: LibraryItems) => {\n    saveLibraries(items);\n    libraryRef.current = items;\n  }, []);\n\n  return { onLibraryChange, libraryItems: libraryRef.current };\n};\n","import { useMemo, useRef } from \"react\";\nimport Excalidraw from \"@excalidraw/excalidraw\";\nimport type {\n  ExcalidrawAPIRefValue,\n  ExcalidrawImperativeAPI,\n} from \"@excalidraw/excalidraw/types/types\";\nimport \"./App.css\";\nimport Claymate from \"./Claymate\";\nimport { Drawing } from \"./types\";\nimport { useScenes } from \"./useScenes\";\nimport { useLibrary } from \"./useLibrary\";\n\nconst App = () => {\n  const excalidrawRef = useRef<ExcalidrawAPIRefValue>(null);\n  const updateDrawing = (drawing: Drawing) => {\n    (excalidrawRef.current as ExcalidrawImperativeAPI | null)?.updateScene(\n      drawing\n    );\n  };\n\n  const {\n    moveToScene,\n    addScene,\n    onChange,\n    drawingVersion,\n    currentIndex,\n    initialData: initialSceneData,\n    scenes,\n    updateScenes,\n  } = useScenes();\n\n  const { onLibraryChange, libraryItems } = useLibrary();\n\n  const initialData = useMemo(() => {\n    if (libraryItems) {\n      return { ...initialSceneData, libraryItems };\n    }\n    return initialSceneData;\n  }, [initialSceneData, libraryItems]);\n\n  return (\n    <div className=\"ClaymateApp\">\n      <Excalidraw\n        ref={excalidrawRef}\n        key={drawingVersion}\n        initialData={initialData}\n        onChange={onChange}\n        onLibraryChange={onLibraryChange}\n      />\n      <Claymate\n        scenes={scenes}\n        currentIndex={currentIndex}\n        updateScenes={updateScenes}\n        moveToScene={moveToScene}\n        addScene={addScene}\n        updateDrawing={updateDrawing}\n      />\n    </div>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import { StrictMode } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}